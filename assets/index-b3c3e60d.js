import*as o from"https://unpkg.com/browse/three@0.152.2/build/three.module.js";import f from"https://unpkg.com/browse/three@0.152.2/examples/jsm/libs/stats.module.js";import{GUI as w}from"https://unpkg.com/browse/three@0.152.2/examples/jsm/libs/lil-gui.module.min.js";import{OrbitControls as M}from"https://unpkg.com/browse/three@0.152.2/examples/jsm/controls/OrbitControls.js";import{GLTFLoader as _}from"https://unpkg.com/browse/three@0.152.2/examples/jsm/loaders/GLTFLoader.js";(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const i of n)if(i.type==="childList")for(const h of i.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&s(h)}).observe(document,{childList:!0,subtree:!0});function e(n){const i={};return n.integrity&&(i.integrity=n.integrity),n.referrerPolicy&&(i.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?i.credentials="include":n.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(n){if(n.ep)return;n.ep=!0;const i=e(n);fetch(n.href,i)}})();class g{constructor(t,e,s){this.scene=t,this.start=e,this.end=s,new _().load("./3d_models/collision-world.glb",i=>{this.model=i,i.scene.position.set(-10,0,0),i.scene.scale.set(5,5,5),i.scene.children[0].material.transparent=!0,i.scene.traverse(h=>{h.isMesh})})}initGeometry(t){const e=new o.PlaneGeometry(1e3,1e3);e.rotateX(-Math.PI/2);const s=new o.MeshMatcapMaterial({color:9861888}),n=new o.Mesh(e,s);n.position.y-=50,this.scene.add(n);const i=new o.Color,h=new o.Object3D;let r=new o.BoxGeometry(.25,.25,.25);const a=new o.MeshMatcapMaterial({color:"white"});let c=new o.InstancedMesh(r,a,2);h.position.set(this.start[0],this.start[1],this.start[1]),h.updateMatrix(),c.setMatrixAt(0,h.matrix),c.setColorAt(0,i.setHex(65280)),h.position.set(this.end[0],this.end[1],this.end[2]),h.updateMatrix(),c.setMatrixAt(1,h.matrix),c.setColorAt(1,i.setHex(16711680)),this.seMesh=c,this.scene.add(c);const l=t.slice(0,6);return l=="Random"?Function("this."+l+"('"+t+"')"):Function("this."+t+"()"),[this.instancedMesh,this.obstacles]}NewRandomCubes(){const t=new o.BoxGeometry(1,1,1),e=new o.MeshMatcapMaterial({color:"white",transparent:!0}),s=new o.InstancedMesh(t,e,3800),n=new o.Color,i=new o.Object3D;let h=[];for(let r=0;r<3800;r++)i.position.set(Math.floor(Math.random()*50),Math.floor(Math.random()*20),Math.floor(Math.random()*50)),!(i.position.x===this.start[0]&&i.position.y==this.start[1]&&i.position.z==this.start[2])&&(i.position.x===this.end[0]&&i.position.y==this.end[1]&&i.position.z==this.end[2]||(i.updateMatrix(),h.push([i.position.x,i.position.y,i.position.z]),i.position.set(i.position.x+.5,i.position.y+.5,i.position.z+.5),i.updateMatrix(),s.setMatrixAt(r,i.matrix),s.setColorAt(r,n.setHex(16777215))));this.scene.add(s),this.instancedMesh=s,this.obstacles=h}Random(t){const e=localStorage.getItem(t),s=JSON.parse(e),n=new o.BoxGeometry(1,1,1),i=new o.MeshMatcapMaterial({color:"white",transparent:!0}),h=new o.InstancedMesh(n,i,3800),r=new o.Color,a=new o.Object3D;for(const[c,l]of s.entries())a.position.set(l[0],l[1],l[2]),!(a.position.x===this.start[0]&&a.position.y==this.start[1]&&a.position.z==this.start[2])&&(a.position.x===this.end[0]&&a.position.y==this.end[1]&&a.position.z==this.end[2]||(a.updateMatrix(),a.position.set(a.position.x+.5,a.position.y+.5,a.position.z+.5),a.updateMatrix(),h.setMatrixAt(c,a.matrix),h.setColorAt(c,r.setHex(16777215))));this.scene.add(h),this.instancedMesh=h,this.obstacles=s}StructuredCubes(){const t=new o.BoxGeometry(1,1,1),e=new o.MeshMatcapMaterial({color:"white",transparent:!0}),s=new o.InstancedMesh(t,e,2e3),n=new o.Color,i=new o.Object3D;let h=[],r=0;for(let a=0;a<13;a++)for(let c=0;c<50;c++)i.position.set(c,a,20),i.updateMatrix(),h.push([i.position.x,i.position.y,i.position.z]),i.position.set(i.position.x+.5,i.position.y+.5,i.position.z+.5),i.updateMatrix(),s.setMatrixAt(r,i.matrix),s.setColorAt(r,n.setHex(16777215)),r++;for(let a=7;a<20;a++)for(let c=0;c<50;c++)i.position.set(c,a,30),i.updateMatrix(),h.push([i.position.x,i.position.y,i.position.z]),i.position.set(i.position.x+.5,i.position.y+.5,i.position.z+.5),i.updateMatrix(),s.setMatrixAt(r,i.matrix),s.setColorAt(r,n.setHex(16777215)),r++;this.scene.add(s),this.instancedMesh=s,this.obstacles=h}RealWorld(){this.scene.add(this.model.scene),this.instancedMesh=this.model.scene.children[0],this.obstacles=null}getObstacles(){return this.scene.remove(this.model.scene),this.scene.add(this.instancedMesh),[this.instancedMesh,this.obstacles]}getCollisionWorld(){return this.scene.remove(this.instancedMesh),this.scene.add(this.model.scene),this.model.scene.children[0]}change_start_end(t,e){this.start=t,this.end=e;const s=new o.Object3D;s.position.set(this.start[0],this.start[1],this.start[1]),s.updateMatrix(),this.seMesh.setMatrixAt(0,s.matrix),this.seMesh.instanceMatrix.needsUpdate=!0,s.position.set(this.end[0],this.end[1],this.end[2]),s.updateMatrix(),this.seMesh.setMatrixAt(1,s.matrix),this.seMesh.instanceMatrix.needsUpdate=!0}dispose_obstacle(){this.instancedMesh.geometry.dispose(),this.instancedMesh.material.dispose(),this.scene.remove(this.instancedMesh)}}class x{constructor(t,e,s,n,i,h=!0){this.scene=t,this.open_set=new Map,this.close_set=[s],this.ground_truth=new Map,this.parents=new Map,this.check=!0,this.current=s,this.start=s,this.end=n,this.obstacles=i,this.simulation=h,this.ground_truth.set(s,0);const r=new o.BoxGeometry(.25,.25,.25),a=new o.MeshMatcapMaterial({color:"white"});this.instanceMesh=new o.InstancedMesh(r,a,50*20*50),this.instanceMesh.count=0,this.instanceMesh.setColorAt(0,new o.Color(0)),t.add(this.instanceMesh)}run(){for(;!this.planning(););this.find_path()}planning(){let t={...this.current},e;const s=[.25,.25,.25,-.25,-.25,-.25];for(let h=0;h<6;h++)e={...t},e[h%3]+=s[h],0<=e[0]&&e[0]<50&&0<=e[1]&&e[1]<20&&0<=e[2]&&e[2]<50&&!this.checkOpenSet(e)&&!this.checkCloseSet(e)&&!this.checkCollision(e)&&(this.ground_truth.set(e,this.getFromMap(this.ground_truth,t)+1),this.open_set.set(e,this.heuristic(e,this.end)),this.parents.set(e,t));if(this.open_set.size==0)return!0;const n=Math.min(...this.open_set.values()),i=[...this.open_set].find(([h,r])=>r===n)[0];return this.open_set.delete(i),this.close_set.push(i),t=i,t[0]==this.end[0]&&t[1]==this.end[1]&&t[2]==this.end[2]?!0:(this.current=t,this.simulation&&this.draw(),!1)}checkOpenSet(t){const e=this.open_set.keys();let s;for(let n=0;n<this.open_set.size;n++)if(s=e.next().value,t[0]==s[0]&&t[1]==s[1]&&t[2]==s[2])return!0;return!1}checkCloseSet(t){for(let e=0;e<this.close_set.length;e++)if(this.close_set[e][0]==t[0]&&this.close_set[e][1]==t[1]&&this.close_set[e][2]==t[2])return!0;return!1}checkCollision(t){for(let e=0;e<this.obstacles.length;e++)if(this.obstacles[e][0]==Math.floor(t[0])&&this.obstacles[e][1]==Math.floor(t[1])&&this.obstacles[e][2]==Math.floor(t[2]))return!0;return!1}getFromMap(t,e){const s=t.keys();let n;for(let i=0;i<t.size;i++)if(n=s.next().value,e[0]==n[0]&&e[1]==n[1]&&e[2]==n[2])return t.get(n)}heuristic(t,e){return Math.sqrt((t[0]-e[0])**2+(t[1]-e[1])**2+(t[2]-e[2])**2)}find_path(){let t=this.end;for(;t=this.getFromMap(this.parents,t),!this.arrayIsEqual(t,this.start);)this.addMesh(t,15732720)}arrayIsEqual(t,e){const s=Object.keys(t).length;if(s==e.length){for(let n=0;n<s;n++)if(t[n]!=e[n])return!1;return!0}return!1}addMesh(t,e){const s=new o.Object3D;s.position.set(t[0]+.125,t[1]+.125,t[2]+.125),s.updateMatrix(),this.instanceMesh.setMatrixAt(this.instanceMesh.count,s.matrix),this.instanceMesh.setColorAt(this.instanceMesh.count,new o.Color(e)),this.instanceMesh.count++,this.instanceMesh.instanceMatrix.needsUpdate=!0,this.instanceMesh.instanceColor.needsUpdate=!0}draw(){this.addMesh(this.current,255)}dispose(){this.instanceMesh.geometry.dispose(),this.instanceMesh.material.dispose(),this.scene.remove(this.instanceMesh)}}class b{constructor(t,e,s,n,i,h){this.scene=t,this.sizes=e,this.start=s,this.end=n,this.lowerLimit=[0,0,0],this.upperLimit=[49,19,49],this.obstacles=i,this.simulation=h,this.step_size=1,this.nodes=[this.start],this.parents=new Map;let r=new o.SphereGeometry(.1),a=new o.MeshPhongMaterial({color:"white"});this.mesh_node=new o.InstancedMesh(r,a,50*50*20),this.mesh_node.count=0,this.mesh_node.setColorAt(0,new o.Color(0)),this.scene.add(this.mesh_node),r=new o.BufferGeometry;const c=new Float32Array(50*50*20*3);r.setAttribute("position",new o.BufferAttribute(c,3)),r.setAttribute("color",new o.BufferAttribute(c,3)),r.setDrawRange(0,0),a=new o.LineBasicMaterial,this.mesh_line=new o.LineSegments(r,a),this.scene.add(this.mesh_line),this.raycaster=new o.Raycaster}run(){for(;!this.planning(););this.find_path()}planning(){let t,e,s,n;for(;t=this.get_rand(),[e,n]=this.get_near(t),!(this.get_distance(e,this.end)<this.step_size+3&&(s=this.end,!this.is_colliding(e,s)));)if(s=this.get_new(e,t,n),!(s[0]<this.lowerLimit[0]||s[0]>this.upperLimit[0]||s[1]<this.lowerLimit[1]||s[1]>this.upperLimit[1]||s[2]<this.lowerLimit[2]||s[2]>this.upperLimit[2])&&!this.is_colliding(e,s))break;return this.checkNodes(s)&&(this.nodes.push(s),this.parents.set(s,e),this.simulation&&this.draw_node(s,e,0)),this.get_distance(s,this.end)==0}get_rand(){return[Math.random()*50*(Math.round(Math.random())*2-1),Math.random()*30,Math.random()*50]}get_near(t){let e=1/0,s=this.nodes.at(-1),n;for(const i of this.nodes)n=this.get_distance(i,t),n<e&&(e=n,s={...i});return[s,e]}get_distance(t,e){return Math.hypot(t[0]-e[0],t[1]-e[1],t[2]-e[2])}get_new(t,e,s){const n=e[0]-t[0],i=e[1]-t[1],h=e[2]-t[2],r=Math.abs(n)+Math.abs(i)+Math.abs(h),a=Math.min(s,this.step_size);return[t[0]+n/r*a,t[1]+i/r*a,t[2]+h/r*a]}is_colliding(t,e){const s=new o.Vector3(t[0],t[1],t[2]),n=new o.Vector3(e[0],e[1],e[2]),i=new o.Vector3;i.subVectors(n,s).normalize(),this.raycaster.set(s,i);const h=new o.Vector3;return this.raycaster.far=h.subVectors(s,n).length(),this.raycaster.intersectObject(this.obstacles).length!=0}checkNodes(t){for(const e of this.nodes)if(this.get_distance(e,t)<.1)return!1;return!0}draw_test(t,e){const s=new o.Object3D;if(s.position.set(t[0],t[1],t[2]),s.updateMatrix(),this.mesh_node.setMatrixAt(this.mesh_node.count,s.matrix),this.mesh_node.setColorAt(this.mesh_node.count,new o.Color(255)),this.mesh_node.count++,this.mesh_node.instanceMatrix.needsUpdate=!0,this.mesh_node.instanceColor.needsUpdate=!0,e){const n=this.mesh_line.geometry.drawRange.count;this.mesh_line.geometry.getAttribute("position").setXYZ(n,e[0],e[1],e[2]),this.mesh_line.geometry.getAttribute("position").setXYZ(n+1,t[0],t[1],t[2]),this.mesh_line.geometry.setDrawRange(0,n+2),this.mesh_line.geometry.attributes.position.needsUpdate=!0}}get_parent(t){const e=this.parents.keys();let s;for(let n=0;n<this.parents.size;n++)if(s=e.next().value,t[0]==s[0]&&t[1]==s[1]&&t[2]==s[2])return this.parents.get(s)}find_path(){let t=this.end,e=t;for(;t;)this.draw_node(t,e,16776960),e=t,t=this.get_parent(t)}draw_node(t,e,s){const n=new o.Object3D;n.position.set(t[0],t[1],t[2]),n.updateMatrix(),this.mesh_node.setMatrixAt(this.mesh_node.count,n.matrix),this.mesh_node.setColorAt(this.mesh_node.count,new o.Color(s)),this.mesh_node.count++,this.mesh_node.instanceColor.needsUpdate=!0,this.mesh_node.instanceMatrix.needsUpdate=!0;const i=this.mesh_line.geometry.drawRange.count;this.mesh_line.geometry.getAttribute("position").setXYZ(i,e[0],e[1],e[2]),this.mesh_line.geometry.getAttribute("position").setXYZ(i+1,t[0],t[1],t[2]),this.mesh_line.geometry.setDrawRange(0,i+2),this.mesh_line.geometry.attributes.position.needsUpdate=!0}dispose(){this.mesh_node.geometry.dispose(),this.mesh_node.material.dispose(),this.scene.remove(this.mesh_node),this.scene.remove(this.mesh_line)}}class y{constructor(t,e,s,n,i,h,r){this.scene=t,this.sizes=e,this.start=s,this.end=n,this.obstacles_mesh=i,this.obstacles=h,this.simulation=r,this.nodes=[this.start],this.parents=new Map,this.open_set=new Map;const a=new o.Vector3(0,0,0);this.open_set.set(this.start,[0,a,a,!1]),this.step_size=1;let c=new o.SphereGeometry(.1),l=new o.MeshMatcapMaterial({color:"white"});this.mesh_node=new o.InstancedMesh(c,l,50*50*20),this.mesh_node.count=0,this.mesh_node.setColorAt(0,new o.Color(0)),this.scene.add(this.mesh_node),c=new o.BufferGeometry;const d=new Float32Array(50*50*20*3);c.setAttribute("position",new o.BufferAttribute(d,3)),c.setAttribute("color",new o.BufferAttribute(d,3)),c.setDrawRange(0,0),l=new o.MeshMatcapMaterial,this.mesh_line=new o.LineSegments(c,l),this.scene.add(this.mesh_line),this.raycaster=new o.Raycaster}run(){for(;!this.planning(););this.simulation=!0,this.find_path()}planning(){if(this.open_set.size==0)return!0;const t=[...this.open_set.values()],e=Math.min(...t.map((n,i)=>n[0])),s=[...this.open_set].find(([n,i])=>i[0]===e)[0];return this.isEqual(s,this.start)?this.open_set.delete(s):this.wallFollow(s),this.targetFollow(s)}isEqual(t,e){for(let s=0;s<t.length;s++)if(t[s]!=e[s])return!1;return!0}targetFollow(t){const e=this.raycast(t,this.end);if(!e)return this.drawNode(this.end,t,255),this.addNode(this.end,t),!0;const s=e.point,n=e.face.normal,i=[s.x+n.x*.1,s.y+n.y*.1,s.z+n.z*.1];if(this.checkExistence(i,i))return!1;this.drawNode(i,t,255),this.parents.set(i,t);const h=this.getCost(i,t);let r=this.rotate(n,Math.PI/2);const a=this.rotate(n,Math.PI);let c=new o.Vector3;return c.crossVectors(r,a),this.open_set.set(i,[h,r,a,c]),this.wallFollow(i),r=this.rotate(r,Math.PI),c=this.rotate(c,Math.PI),this.open_set.set(i,[h,r,a,c]),this.wallFollow(i),this.addNode(i,t),!1}raycast(t,e){const s=new o.Vector3(t[0],t[1],t[2]),n=new o.Vector3(e[0],e[1],e[2]),i=new o.Vector3;i.subVectors(n,s).normalize(),this.raycaster.set(s,i);const h=new o.Vector3;this.raycaster.far=h.subVectors(s,n).length();const r=this.raycaster.intersectObject(this.obstacles_mesh);return r.length==0?!1:r[0]}wallFollow(t){let[e,s,n,i]=this.open_set.get(t);this.open_set.delete(t);let h=[...t],r,a;Object.values(s).map((p,m)=>{p&&(r=m,a=p)}),h[r]=Math.round(h[r]);let c;i?(h[r]==t[r]&&(c=[h[0]+n.x*.2,h[1]+n.y*.2,h[2]+n.z*.2],this.checkCollision(c)&&(h[r]+=1)),a>0?h[r]-=.1:h[r]>=t[r]&&(h[r]-=1)):a>0?h[r]+=.1:h[r]-=.1;let l=!1,d=h;for(;;){if(c=[h[0]+n.x*.2,h[1]+n.y*.2,h[2]+n.z*.2],this.checkCollision(h)?(l=!0,h=d,i||(i=this.rotate(n,Math.PI),n=s)):this.checkCollision(c)||(l=!0,i?h=d:(i=n,n=this.rotate(s,Math.PI))),l){if(this.checkExistence(h,t))return;this.drawNode(h,t,255),this.addNode(h,t);const p=this.getCost(h,t);this.open_set.set(h,[p,i,n,!1]);return}d=[...h],h=[h[0]+s.x*this.step_size,h[1]+s.y*this.step_size,h[2]+s.z*this.step_size]}}checkCollision(t){for(let e=0;e<this.obstacles.length;e++)if(this.obstacles[e][0]==Math.floor(t[0])&&this.obstacles[e][1]==Math.floor(t[1])&&this.obstacles[e][2]==Math.floor(t[2]))return!0;return!1}checkExistence(t,e){for(const s of this.nodes)if(this.getDistance(s,t)<.3){if(s[0]==e[0]&&s[1]==e[1]&&s[2]==e[2])continue;return!0}return!1}getCost(t,e){return this.getDistance(t,this.end)}getDistance(t,e){return Math.hypot(t[0]-e[0],t[1]-e[1],t[2]-e[2])}getMapValue(t,e){const s=e.keys();let n;for(let i=0;i<e.size;i++)if(n=s.next().value,t[0]==n[0]&&t[1]==n[1]&&t[2]==n[2])return e.get(n)}del(t,e){const s=e.keys();let n;for(let i=0;i<e.size;i++)if(n=s.next().value,t[0]==n[0]&&t[1]==n[1]&&t[2]==n[2])return e.delete(n),!0;return!1}addNode(t,e){this.nodes.push(t),this.parents.set(t,e)}getDirection(t,e){const s=[t[0]-e[0],t[1]-e[1],t[2]-e[2]],n=Math.sqrt(s[0]**2+s[1]**2+s[2]**2);return[s[0]/n,s[1]/n,s[2]/n]}rotate(t,e){let s={...t};return t.y!=0?(s.x=Math.round(Math.cos(e)*t.x-Math.sin(e)*t.y),s.y=Math.round(Math.sin(e)*t.x+Math.cos(e)*t.y)):(s.x=Math.round(Math.cos(e)*t.x-Math.sin(e)*t.z),s.z=Math.round(Math.sin(e)*t.x+Math.cos(e)*t.z)),s}find_path(){let t=this.end,e=t;for(;t;)this.drawNode(t,e,16776960),e=t,t=this.getMapValue(t,this.parents)}drawNode(t,e,s){if(this.simulation){const n=new o.Object3D;n.position.set(t[0],t[1],t[2]),n.updateMatrix(),this.mesh_node.setMatrixAt(this.mesh_node.count,n.matrix),this.mesh_node.setColorAt(this.mesh_node.count,new o.Color(s)),this.mesh_node.count++,this.mesh_node.instanceColor.needsUpdate=!0,this.mesh_node.instanceMatrix.needsUpdate=!0;const i=this.mesh_line.geometry.drawRange.count;this.mesh_line.geometry.getAttribute("position").setXYZ(i,e[0],e[1],e[2]),this.mesh_line.geometry.getAttribute("position").setXYZ(i+1,t[0],t[1],t[2]),this.mesh_line.geometry.setDrawRange(0,i+2),this.mesh_line.geometry.attributes.position.needsUpdate=!0}}drawCircle(t,e){const s=new o.Object3D;s.position.set(t[0],t[1],t[2]),s.updateMatrix(),this.mesh_node.setMatrixAt(this.mesh_node.count,s.matrix),this.mesh_node.setColorAt(this.mesh_node.count,new o.Color(e)),this.mesh_node.count++,this.mesh_node.instanceColor.needsUpdate=!0,this.mesh_node.instanceMatrix.needsUpdate=!0}dispose(){this.mesh_node.geometry.dispose(),this.mesh_node.material.dispose(),this.scene.remove(this.mesh_node),this.scene.remove(this.mesh_line)}}class z{constructor(){this.scene=new o.Scene,this.clock=new o.Clock,this.delta=0,this.FPS=100,this.getWinSize(),this.initFPS(),this.initGUI(),this.initEvenListeners(),this.initHelpers(),this.check=!1,this.start=[0,0,0],this.end=[40,15,40],this.initLight(),this.initCamera(),this.initAction(),this.env=new g(this.scene,this.start,this.end),[this.obstacles_mesh,this.obstacles]=this.env.initGeometry("Random2")}getWinSize(){this.winSize={width:window.innerWidth,height:window.innerHeight}}initFPS(){this.stats=new f,this.stats.showPanel(0),document.body.append(this.stats.dom)}initGUI(){const t=new w({width:200}),e=t.addFolder("Start Position"),s=t.addFolder("End Position"),n=t.addFolder("Settings"),i=this;this.props={Simulation:!0,Speed:100,Env:"Random2",Algo:"RBT",Apply:function(){i.onApply()},Run:function(){i.onRun()},"Pause/Resume":function(){i.check=!i.check},Save:function(){i.onSave()}},this.startObj={x:0,y:0,z:0},this.endObj={x:40,y:15,z:40},e.add(this.startObj,"x",-50,50),e.add(this.startObj,"y",-50,50),e.add(this.startObj,"z",-50,50),s.add(this.endObj,"x",-50,50),s.add(this.endObj,"y",-50,50),s.add(this.endObj,"z",-50,50),n.add(this.props,"Simulation"),n.add(this.props,"Speed",1,200),n.add(this.props,"Env",["New Random Cubes","Structured Cubes","Real World","Random1","Random2"]),n.add(this.props,"Apply"),n.add(this.props,"Algo",["Astar","RRT","RBT"]),n.add(this.props,"Run"),n.add(this.props,"Pause/Resume"),n.add(this.props,"Save"),t.close()}onApply(){this.start=[this.startObj.x,this.startObj.y,this.startObj.z],this.end=[this.endObj.x,this.endObj.y,this.endObj.z],this.env.change_start_end(this.start,this.end),this.env.dispose_obstacle(),this.algo&&this.algo.dispose(),[this.obstacles_mesh,this.obstacles]=this.env.initGeometry(this.props.Env.replace(/ /g,""))}onRun(){this.algo&&this.algo.dispose(),this.props.Algo=="Astar"?this.algo=new x(this.scene,this.winSize,this.start,this.end,this.obstacles,this.props.Simulation):this.props.Algo=="RBT"?this.algo=new y(this.scene,this.winSize,this.start,this.end,this.obstacles_mesh,this.obstacles,this.props.Simulation):this.algo=new b(this.scene,this.winSize,this.start,this.end,this.obstacles_mesh,this.props.Simulation),this.check=!0}onSave(){const t=JSON.stringify(this.obstacles);localStorage.setItem("Random2",t)}initEvenListeners(){window.addEventListener("resize",()=>{this.getWinSize(),this.canvas.width=this.winSize.width,this.canvas.height=this.winSize.height,this.camera.aspect=this.winSize.width/this.winSize.height,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.winSize.width,this.winSize.height)}),window.addEventListener("keypress",s=>{s.code==="KeyH"&&(this.obstacles_mesh.visible=!this.obstacles_mesh.visible),s.code==="KeyT"&&(this.obstacles_mesh.material.opacity==.5?this.obstacles_mesh.material.opacity=1:this.obstacles_mesh.material.opacity=.5)});const t=document.getElementById("blocker"),e=document.getElementById("instructions");e.addEventListener("click",function(){e.style.display="none",t.style.display="none"})}initHelpers(){const t=new o.AxesHelper(5);this.scene.add(t)}initLight(){this.scene.background=new o.Color(43775),this.scene.fog=new o.Fog(43775,0,500),new o.AmbientLight(13421772);const t=new o.DirectionalLight(16777215,2);t.position.set(0,10,10),this.scene.add(t)}initCamera(){this.camera=new o.PerspectiveCamera(45,this.winSize.width/this.winSize.height),this.camera.position.set(19,73,19),this.scene.add(this.camera)}initAction(){const t=document.querySelector(".webgl");this.renderer=new o.WebGLRenderer({canvas:t}),new o.PMREMGenerator(this.renderer),this.renderer.setSize(this.winSize.width,this.winSize.height),this.controls=new M(this.camera,t),this.canvas=t}loop(){var t=this;const e=document.getElementById("result");this.renderer.setAnimationLoop(()=>{if(t.delta+=1,t.FPS=Math.round(100/t.props.Speed),t.delta%t.FPS==0&&t.check)if(t.props.Simulation)t.algo.planning()&&(t.check=!1);else{const s=new Date;t.algo.run();const n=new Date-s+" ms";console.log(n),e.innerHTML=n,t.check=!1}t.stats.update(),t.controls.update(),t.renderer.render(t.scene,t.camera)})}}const A=new z;A.loop();
